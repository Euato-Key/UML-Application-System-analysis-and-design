


我们现在做的是实验三
你先通读整个项目，然后我现在要建立代码骨架

# Role
你是一名 Python 高级架构师，正在使用 FastAPI 和 Neo4j 开发“物联网设备知识图谱交互管理平台”。

# Task
请基于以下 **PlantUML 类图** 中的 "Domain Layer" 和 "Infrastructure Layer"，生成 Python 代码。

# Requirements
1. **Domain Models**: 使用 Pydantic (`pydantic.BaseModel`) 定义实体类。
   - 文件路径: `app/domain/models.py`
   - 必须包含 Docstring，并在 Docstring 中包含需求追踪标记，格式为: `Trace: [UC-xx]`。
2. **Infrastructure**: 使用 `neo4j` 官方驱动编写数据库适配器。
   - 文件路径: `app/infra/graph_db.py`
   - 实现类图中 `GraphRepository` 接口的方法 (executeCypher, mergeNode 等)。
   - 同样需要添加 Trace 标记。

# Input (PlantUML Class Diagram Partial)
(在此处粘贴之前生成的类图代码，主要包含 Domain 和 Infrastructure 部分)

# Output Format
请使用 Python 代码块输出，分文件展示。
基于已有的 Domain 模型，生成应用服务层代码（Service Layer）。

# Requirements
1. **Files**:
   - `app/services/topology_svc.py` (实现 UC-02 构建拓扑)
   - `app/services/agent_svc.py` (实现 UC-04 智能问答，需模拟调用 LLM 和 GraphDB)
   - `app/services/lifecycle_svc.py` (实现 UC-07 设备退役)
2. **Logic**:
   - 严格遵循 **序列图** 的逻辑（例如：退役时先擦除数据，再删图谱关系）。
   - 引用 `app.infra` 中的类进行数据库和 LLM 交互。
3. **Traceability**:
   - 在每个**类**和**关键方法**的 Docstring 中加入需求追踪标记。
   - 格式示例：
     ```python
     class TopologyService:
         """
         处理设备与空间的拓扑关系。
         Trace: [UC-02]
         """
         def bind_space(self, device_id: str, space_id: str):
             """
             绑定设备到指定空间。
             Trace: [UC-02]
             """
             pass
     ```

# Input (PlantUML Sequence Diagram Context)
(在此处粘贴 UC-02, UC-04, UC-07 的序列图代码，或者简述其核心逻辑步骤)


# Task
生成 Web API 路由代码。

# Requirements
1. **File**: `app/api/routers.py` 和 `app/main.py`
2. **Details**:
   - 为每个 Service 中的方法暴露对应的 RESTful API (POST/GET)。
   - 使用 FastAPI 的 `APIRouter`。
   - 使用 Dependency Injection 注入 Service 实例。
   - 在路由函数文档注释中加入 Trace 标记，例如 `Trace: [UC-xx]`。
3. **Trace Output**:
   - 确保 `main.py` 启动后，访问 `/docs` 可以看到Swagger文档。

# Input
基于前两步生成的 Service 类方法签名。
